/*
Seems to be a custom type of raw data which is generated by the 
upsampling and cleaning algorithm. Here is some info I have:
13byte string ("BitmapFrame")
32bit unsigned int version number
32bit signed int widht
32bit signed int heigth
32bit unsigned int format
32bit signed int stride

Since I ran the code on my machine, it should be little endian.

Pixels are than read by
*data = new unsigned char[stride * height];
*/
#include <assert.h>
#include <errno.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "crop.h"
#include "obj-write.h"
#include "minmax.h"
#include "wrpng.h"

static int less(const void* a, const void* b) {
  uint64_t aa = *(const uint64_t*)a;
  uint64_t bb = *(const uint64_t*)b;
  if(aa < bb) {
    return -1;
  } else if(aa > bb) {
    return 1;
  }
  assert(aa == bb);
  return 0;
}

int main(int argc, char* argv[]) {
  if(argc != 3) {
    fprintf(stderr, "Usage: %s depthimage SRA\n", argv[0]);
    exit(EXIT_FAILURE);
  }
  FILE* depth = fopen(argv[1], "r");
  if(!depth) {
    fprintf(stderr, "could not open file.\n");
    exit(EXIT_FAILURE);
  }
  char magic[14] = {0};
  if(fread(magic, 1, 1, depth) != 1) {
    fprintf(stderr, "short read.\n"); exit(EXIT_FAILURE);
  }
  if(magic[0] != 0x0b) {
    fprintf(stderr, "expected vertical tab as first char.\n");
    exit(EXIT_FAILURE);
  }
  if(fread(magic, 1, 11, depth) != 11) {
    fprintf(stderr, "short read.\n"); exit(EXIT_FAILURE);
  }
  if(strncmp(magic, "BitmapFrame", 11) != 0) {
    fprintf(stderr, "magic is '%s', not 'BitmapFrame'\n", magic);
    exit(EXIT_FAILURE);
  }

/*
32bit unsigned int version number
32bit signed int widht
32bit signed int heigth
32bit unsigned int format
32bit signed int stride
*/
  unsigned int version, format;
  int width, height, stride;
  errno=0;
  if(fread(&version, sizeof(unsigned int), 1, depth) != 1) {
    perror("short read grabbing version");
    exit(EXIT_FAILURE);
  }
  if(fread(&width, sizeof(int), 1, depth) != 1) {
    fprintf(stderr, "short read grabbing width.\n");
    exit(EXIT_FAILURE);
  }
  if(fread(&height, sizeof(int), 1, depth) != 1) {
    fprintf(stderr, "short read grabbing height.\n");
    exit(EXIT_FAILURE);
  }
  if(fread(&format, sizeof(unsigned int), 1, depth) != 1) {
    fprintf(stderr, "short read grabbing format.\n");
    exit(EXIT_FAILURE);
  }
  if(fread(&stride, sizeof(int), 1, depth) != 1) {
    fprintf(stderr, "short read grabbing stride.\n");
    exit(EXIT_FAILURE);
  }
  printf("version %u, format %u, stride: %d\n", version, format, stride);
  printf("%dx%d image\n", width, height);

  if(width < 0) {
    fprintf(stderr, "negative width (%d) makes no sense.\n", width);
    exit(EXIT_FAILURE);
  }
  if(height < 0) {
    fprintf(stderr, "negative height (%d) makes no sense.\n", height);
    exit(EXIT_FAILURE);
  }
  uint32_t w = (uint32_t) width;
  assert(width*2 == stride);
  /* the "stride" is actually the width, or rather the width with the
   * bit width in it. */
  /* uint32_t w = (uint32_t) stride; */
  uint32_t h = (uint32_t) height;
  uint8_t* data = calloc(w*h + w, sizeof(uint16_t));
  if(fread(data, 2, w*h, depth) != w*h) {
    perror("short data read");
    exit(EXIT_FAILURE);
  }
  fclose(depth);

  bstream_t typ = {
    UNSIGNED_INTEGER,
    sizeof(uint16_t),
    1,
    { w, h, 1, 1 }
  };
  crop* c = new_crop();
  c->parent->set_input(c->parent, data, typ);
  c->set_axis(c, 0);
  c->set_index(c, 176); /* hack, static for kinect data! */
  c->set_comparator(c, less);
  if(!c->parent->execute(c)) {
    fprintf(stderr, "cropping failed...\n");
  }
  stream out = c->parent->output(c->parent, 0);

  writepng("test.png", (uint16_t*)out.data, out.info.dimensions[0],
           out.info.dimensions[1]);
  free_crop(c);

  minmax* mm = new_minmax();
  mm->parent->set_input(mm->parent, data, typ);
  if(!mm->parent->execute(mm)) {
    fprintf(stderr, "minmax failed.\n");
  }
  out = mm->parent->output(mm->parent, 0);
  fprintf(stderr, "min: %hu\n", ((const uint16_t*)out.data)[0]);
  fprintf(stderr, "max: %hu\n", ((const uint16_t*)out.data)[1]);
  free_minmax(mm);

  free(data);

  return EXIT_SUCCESS;
}
